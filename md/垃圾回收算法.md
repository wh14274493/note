# 垃圾回收

- ## 引用计数法

  > 存在循环引用导致内存泄漏的问题

- ## 可达性分析算法（GCROOT）

  > 解决了引用计数法的内存泄露问题
  >
  > 可作为ROOT节点的元素：
  >
  > 1.  虚拟机栈、本地方法栈中的变量
  > 2. 方法区中的静态变量
  > 3. 方法区中常量池的引用
  > 4. synchronized持有的对象
  > 5. 核心类库对应的Class对象，如基本数据类型、异常对象
  >
  > GCROOT分析小技巧：
  >
  > 理论上收集区域的周边区域都可以作为GCROOT，如只收集新生代，那么老年代的对象也可以作为GCROOT

- ## finalize机制

  > 对象的三种状态：
  >
  > 1. 可触及的：从GCROOT出发可以找到这个对象
  > 2. 可复活的：从GCROOT出发不能找到这个对象，且**重写了finalize方法但是finalize方法还没被调用过，此时对象会被放到F-Queue中，由finalizer线程去执行对象的finalize方法**，因此可以在finalize方法中将对象复活，但是**复活机会只有一次**。
  > 3. 不可触及的：从GCROOT出发不能找到这个对象，且**finalize方法已经被调用过或者是没有重写过finalize方法**，对象即将被回收

- ## 垃圾回收算法

  - #### 标记清除

    > 一阶段将被GCRoot对象引用的对象标记出来（此时使用递归遍历，类似于dfs），二阶段线性遍历所有区域清理没有被标记的垃圾。这里的清理并不是把内容抹除了，而是使用一张空闲列表来记录清理空间起始和结束地址。
    >
    > 优点：
    >
    > 1. 简单
    >
    > 缺点：
    >
    > 1. 效率不高
    > 2. 标记阶段会STW
    > 3. 需要维护空闲列表，会产生内存碎片

    

  - #### 标记整理

    > 一阶段将被GCRoot对象引用的对象标记出来，二阶段将被标记存活的对象全部移动到一起。
    >
    > 优点：
    >
    > 1. 相比标记清除算法不需要维护空闲列表，只需要维护回收后的空闲起始地址即可，因此没有内存碎片问题
    > 2. 相比复制算法不需要浪费额外空间
    >
    > 缺点：
    >
    > 1. 效率很低
    > 2. 因为涉及到对象内存的地址的改变，在垃圾回收后还要去修改某些局部变量所引用的地址值
    > 3. 需要STW

  - #### 复制算法

    > 需要两块大小相同的内存空间from和to，从from中的GCROOT对象出发递归遍历，将遍历到的对象复制到to区域，交换from和to区域
    >
    > 优点：
    >
    > 1. 没有标记和清除阶段，效率相对较高
    > 2. 复制到to区域后内存地址连续，不会产生内存碎片
    >
    > 缺点：
    >
    > 1. 会浪费一半的内存空间
    > 2. 涉及到对象内存的地址的改变，在垃圾回收后还要去修改某些局部变量所引用的地址值
    >
    > **启示：适合回收效率比较高的情况下使用，如回收新生代。**

    ------

  - #### 分代回收算法

    > 新生代使用复制算法minor gc，老年代一般使用标记整理或者标记清除算法，当老年代或者方法区空间不足的时候会触发full gc同时回收老年代，新生代和方法区，只有当新生代的eden区满了以后会触发minor gc

- ## 垃圾回收器

  - #### 串行

    > 适用于单核cpu机器，且内存空间不大的情况

  - #### 吞吐量优先

    > 适用于多核cpu机器，且要求单位时间内STW时间最少

  - #### 响应时间优先

    > 适用于多核cpu机器，且要求单次STW时间最少

- ## 常用垃圾回收器

  - #### Serial收集器

    > Serial收集器使用复制算法收集新生代
    >
    > Serial old收集器使用标记-整理算法收集老年代
    >
    > 通过-XX:+UseSerialGC 配置新生代使用Serial收集器，老年代使用Serial old收集器

  - #### ParNew收集器

    > 一款并行的收集器，Serial收集器的多线程版本。任然采用复制算法收集新生代
    >
    > ParNew可以搭配CMS或者Serial old收集老年代
    >
    > 通过-XX:+UserParNewGC 配置新生代使用ParNew收集器，通过-XX:ParallelGCThreads限制线程数量，默认开启和CPU核数相同数量的线程

  - #### Parallel收集器

    > Parallel是一款并行收集器，同时也是一款吞吐量优先的收集器，适合后台运算而不需要大量交互情况下使用，JDK8中默认使用
    >
    > Parallel Scavenge使用复制算法收集新生代
    >
    > 通过-XX:+UseParallelGC配置新生代使用Parallel Scavenge收集器
    >
    > Parallel Old使用标记-整理算法收集老年代
    >
    > 通过-XX:+UseParallelOldGC配置新生代使用Parallel Scavenge收集器
    >
    > 通过-XX:ParallelGCThreads限制线程数
    >
    > Parallel收集器的自适应策略是和ParNew收集器最大的区别，可以通过自动控制堆空间的大小和比例来调节吞吐量和STW开销，默认开启了-XX:UseAdaptiveSizePolicy

  - #### CMS（Concurrent Mark Sweep）收集器

    > 第一款真正意义上的并发（**允许用户线程和垃圾回收线程同时运行**）收集器
    >
    > CMS收集器使用标记清除算法收集老年代
    >
    > CMS的关注点是尽可能减少STW时间，因此适合交互常见比较多的情况下使用
    >
    > 使用-XX:+UserConcMarkSweepGC配置开启CMS收集器
    >
    > CMS收集器主要有五个阶段：
    >
    > 1. 初始标记
    >
    >    这个阶段会暂停所有的用户线程，但是仅仅**只是标记GCROOT直接关联的对象**，因此这里速度非常快，结束之后就会恢复用户线程
    >
    > 2. 并发标记
    >
    >    这个阶段从GCROOT直接关联的对象开始遍历整个对象图，这个过程比较耗时但是不需要暂停用户线程，**可以和用户线程并发运行**
    >
    > 3. 重新标记
    >
    >    这个阶段会**修正上一个阶段用户线程并发执行导致标记结果不准确的问题**，时间相对初始标记阶段要长，但是远小于并发标记阶段所需时间，同时这一阶段也**会暂停所有用户线程**
    >
    > 4. 并发清理
    >
    >    清除上一阶段标记死亡的对象，这一阶段可以和用户线程并发运行，因此会导致内存碎片问题产生
    >
    > 5. 重置线程
    >
    > 注意：因为用户线程可以和垃圾回收线程并发执行，所以不能等到老年代区域满了以后再进行回收，而是当堆内存达到某个阈值以后就开始进行回收，以确保用户线程可以继续正常执行。如果预留空间已经不足以支持用户线程继续运行，那么会出现一次“Concurrent Mode Failure”失败，此时会启用后备方案使用Serial Old收集器暂停所有用户线程进行回收
    >
    > 
    >
    > 优点：
    >
    > 1. 可以和用户线程并发运行，延迟低
    >
    > 缺点：
    >
    > 1. 会产生内存碎片，但是JVM提供了参数可以设置在执行了多少次full gc之后对内存空间进行整理但是这会使用STW时间更长
    > 2. 并发标记和并发处理阶段需要占用CPU资源导致用户线程可以资源减少，降低了吞吐量
    > 3. 重新标记阶段只能修正并发标记阶段错误标记的对象，无法回收上一阶段新产生的垃圾对象

  - #### G1收集器：区域分代

    > G1收集器旨在高吞吐量的情况下，尽量降低STW时间
    >
    > 
    >
    > G1收集器将堆划分为一个个region，每个region的大小取值范围为1MB-32MB，且应该为2的n次幂，使用不同的region来表示eden、survivor0、survivor1、old区域，除此之外还有一类特殊的区域Humongous用来存储大对象（大小超过一个region的一半）且不要求区域是连续的，以此来尽量避免全堆回收。同时G1收集器会维护一个优先列表，这个列表中记录了每个区域回收的价值（回收所获得的空间大小以及回收所需时间），每次在允许时间内优先回收价值比较高的区域
    >
    > 
    >
    > G1收集器回收过程：
    >
    > 1. 新生代GC：
    >    1. 扫描GCROOT，注意此时除了扫描常规的GCROOT意外还会扫描RememberSet（记忆集，记录了堆中其它指向了当前扫描区域的引用位置，方便GCROOT的查找，避免整堆搜索）
    >    2. 