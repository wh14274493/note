# 深入理解JVM

- ### PC寄存器

  ```
  pc寄存器中存储的是下一条将要执行的指令地址，是物理pc寄存器的一个抽象化实现，每个线程独有一份。唯一一个不会发生OOM的区域
  ```

- ### 虚拟机栈、本地方法栈

  ```
  hotspot中将本地方法栈和虚拟机合二为一
  
  栈中存在一个个的栈帧，每个栈帧对应一个方法
  
  栈帧中又包含局部变量表、操作数栈、方法返回地址、动态链接信息等
  
  局部变量表和操作数栈的大小在编译成字节码的时候就已经确定了，且操作数栈中32bit的数据占用一个栈单位，64bit数据（long、double）占用两个栈单位，局部变量表中也是一样。
  
  栈大小不固定的情况下，随着一个个栈帧的创建，如果最终没法分配内存则会出现OOM
  栈大小固定的情况下，随着一个个栈帧的创建，如果最终没法分配内存则会出现StackOverFlow
  栈中不存在GC
  
  栈的大小通过-Xss来设置，但是不是越大越好，因为每个线程都对应一个虚拟机栈，如果栈的大小越大，在内存固定的情况下可创建的线程数就会减少
  ```

- ### 堆

  ```
  一般来说对象的创建都是在堆中的，但是因为逃逸分析的出现，对象的分配可以在栈上。这里说的栈上分配只是表面上看起来像是在栈上创建了一个对象，实际上是因为有标量替换的存在，对象可以被拆分成一个或者多个标量的情况下，可以将对象的创建转变为标量的声明。如下所示， 方法A执行时的效果和方法B类似
  class T{
  	int a;
  	int b;
  }
  
  public void A(){
  	T t = new T();
  }
  
  public void B(){
  	int a;
  	int b;
  }
  ```

- ### 方法区

  ```
  主要存放类型信息、常量、静态 变量、JIT即时编译器的缓存代码
  
  jdk1.6中静态变量和字符串常量池存放在永久代
  jdk1.7中静态变量和字符串常量池从永久代搬迁到堆中
  jdk1.8中静态变量和字符串常量池仍保存在堆中，但是移除了永久代，取而代之的是使用本地内存来保存类元信息
  jdk1.7及之后的hotspoot虚拟机将静态变量和对应Class对象存放到一起，存储与堆中，可以使用jdk9中自带工具jhsdb查看
  
  为什么jdk1.7及以后StringTable搬迁到堆中？
StringTable放在perm中受限于perm的大小限制，其次perm中gc的频率比较低，后手效率不好
  
  jdk1.7中方法区的落地实现是perm永久代
  jdk1.8中方法区的落地实现是metaspace元空间
  
  为什么jdk1.8中将方法区的实现移动到本地内存？
  方法区的空间大小不好确定，可能随着程序运行需要加载大量的类，而方法区的回收又是异常的困难，可能导致full gc的频繁发生甚至OOM，然而使用本地内存却不会有这样的困扰
  
  jdk1.8中可以通过-XX:MaxMetaspaceSize和-XX:MetaspaceSize来设置原空间最大大小和初始大小，模式最大小时-1（没有限制），初始化大小为21M。因为随着大量的类被加载进入方法区，有可能导致metaspaceSize动态扩张，且发生full gc，因此可以将-XX:MetaspaceSize设置相对较大一点来避免频繁出现full gc
  
  
  ```
  
  